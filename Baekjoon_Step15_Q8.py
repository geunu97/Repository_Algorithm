#15단계: 동적 계획법1 (DP 다이나믹프로그래밍)
#8. 1로 만들기

n = int(input())
dp = [0] * (n + 1)

for i in range(2, n + 1):
    dp[i] = dp[i - 1] + 1 # 1 빼는 경우
    if i % 2 == 0: # 2로 나눠서 나머지 없는 경우
        dp[i] = min(dp[i], dp[i // 2] + 1)
    if i % 3 == 0: # 3로 나눠서 나머지 없는 경우
        dp[i] = min(dp[i], dp[i // 3] + 1)                        #3가지 경우의 수 모두 비교해서 그 중에서 최솟값은 현재 자리가 됨

print(dp[n])

# 결과값 낼 때 이전의 값들이 이용된다 싶으면 dp
#dp 배열에 저장되는 값 : 해당 인덱스 값을 1로 만들 때 사용되는 연산의 최솟값
#그래서, i를 1로 만들기 위해  사용되는 연산의 최솟값 = 
#1. i - 1에서 더하기1 연산 하면 i 니까, dp[i - 1] + 1
#2. i가 2로 나누어 떨어진다면, dp[i / 2] + 1
#3. i가 3로 나누어 떨어진다면, dp[i / 3] + 1
#이 중 최솟값이 dp[i]임




